stages:
  - build
  - deploy
  - destroy

variables:
  TF_ROOT: "terraform/environments/example"
  CHEF_ROOT: "chef"
  ENV_NAME: "${TF_VAR_service}-${TF_VAR_stage_name}${TF_VAR_stage}"
  FQDN: "${TF_VAR_dns:-example.com}"
  ENV_URL: "https://${FQDN}"
  SKIP_KITCHEN: "false"

.parse_manifest:
  script:
    - mkdir -p scripts/manifest
    - |
      if [[ -n "${MANIFEST_TAG:-}" ]]; then
        bash scripts/manifest/parse_manifest.sh
      else
        echo "MANIFEST_TAG not set; writing default build.env"
        {
          echo "export BE_TAG="
          echo "export FE_TAG="
          echo "export INFRA_TAG="
        } > build.env
      fi
  artifacts:
    name: "build-env"
    paths:
      - build.env
    when: always
  rules:
    - if: '$PHASE == "APPLY"'
    - if: '$PHASE == "DESTROY"'

.deploy_template:
  image: ruby:3.1
  stage: deploy
  before_script:
    - apt-get update -y
    - apt-get install -y curl jq unzip openssh-client
    - |
      if ! command -v terraform >/dev/null 2>&1; then
        TERRAFORM_VERSION=${TERRAFORM_VERSION:-1.5.7}
        curl -fsSL "https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip" -o terraform.zip
        unzip terraform.zip
        mv terraform /usr/local/bin/terraform
      fi
  script:
    - echo "Phase: ${PHASE:-APPLY}"
    - source build.env || true
    - terraform -chdir="$TF_ROOT" init
    - terraform -chdir="$TF_ROOT" plan -out=plan.tfplan
    - |
      if [[ "${PHASE}" == "APPLY" ]]; then
        terraform -chdir="$TF_ROOT" apply -auto-approve plan.tfplan
      else
        echo "Skipping apply because PHASE=${PHASE}"
      fi
    - bash ${CHEF_ROOT}/scripts/gen_env_from_terraform.sh "$TF_ROOT"
    - |
      if [[ "${SKIP_KITCHEN}" == "true" ]]; then
        echo "SKIP_KITCHEN=${SKIP_KITCHEN}; skipping Kitchen converge/verify."
      else
        pushd ${CHEF_ROOT}
        bundle install --path vendor/bundle
        bundle exec kitchen list
        bundle exec kitchen converge
        bundle exec kitchen verify
        popd
      fi
  after_script:
    - |
      STATUS="failed"
      if [[ "${CI_JOB_STATUS}" == "success" ]]; then
        STATUS="success"
      fi
      ENV_NAME=${ENV_NAME} TF_VAR_service=${TF_VAR_service} bash scripts/callbacks/callback.sh ${STATUS} deploy || true
  artifacts:
    paths:
      - ${CHEF_ROOT}/.env
    when: always
  rules:
    - if: '$PHASE == "APPLY"'

.destroy_template:
  image: ruby:3.1
  stage: destroy
  before_script:
    - apt-get update -y
    - apt-get install -y curl jq unzip openssh-client
    - |
      if ! command -v terraform >/dev/null 2>&1; then
        TERRAFORM_VERSION=${TERRAFORM_VERSION:-1.5.7}
        curl -fsSL "https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip" -o terraform.zip
        unzip terraform.zip
        mv terraform /usr/local/bin/terraform
      fi
  script:
    - source build.env || true
    - terraform -chdir="$TF_ROOT" init
    - terraform -chdir="$TF_ROOT" destroy -auto-approve || true
  after_script:
    - |
      STATUS="failed"
      if [[ "${CI_JOB_STATUS}" == "success" ]]; then
        STATUS="success"
      fi
      ENV_NAME=${ENV_NAME} TF_VAR_service=${TF_VAR_service} bash scripts/callbacks/callback.sh ${STATUS} destroy || true
  rules:
    - if: '$PHASE == "DESTROY"'

parse_manifest:
  stage: build
  extends: .parse_manifest

deploy:
  extends: .deploy_template

cleanup:
  extends: .destroy_template
